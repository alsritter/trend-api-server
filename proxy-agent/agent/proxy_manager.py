"""
3proxy 代理管理器
负责管理 3proxy 进程的启动、停止、配置等
"""

import os
import subprocess
import logging
import platform
import time
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)


class ProxyManager:
    """3proxy 代理管理器"""

    def __init__(self, config: dict):
        """
        初始化代理管理器

        Args:
            config: 配置字典
        """
        self.config = config
        self.proxy_type = config["agent"]["proxy_type"]
        self.proxy_port = config["agent"]["proxy_port"]
        self.proxy_username = config["agent"].get("proxy_username", "")
        self.proxy_password = config["agent"].get("proxy_password", "")

        # 3proxy 配置
        self.executable = config["3proxy"].get("executable", "")
        self.config_file = config["3proxy"]["config_file"]
        self.log_file = config["3proxy"]["log_file"]

        # 进程对象
        self.process: Optional[subprocess.Popen] = None

        # 自动检测可执行文件
        if not self.executable:
            self.executable = self._find_executable()

    def _find_executable(self) -> str:
        """
        查找 3proxy 可执行文件

        Returns:
            str: 可执行文件路径
        """
        system = platform.system()

        # 项目目录下的 3proxy 文件夹
        base_dir = Path(__file__).parent.parent
        proxy_dir = base_dir / "3proxy"

        if system == "Windows":
            executable = proxy_dir / "3proxy.exe"
        else:
            executable = proxy_dir / "3proxy"

        if executable.exists():
            logger.info(f"Found 3proxy executable: {executable}")
            # Linux 下确保有执行权限
            if system != "Windows":
                os.chmod(str(executable), 0o755)
            return str(executable)

        # 尝试从系统 PATH 查找
        if system == "Windows":
            executable_name = "3proxy.exe"
        else:
            executable_name = "3proxy"

        # 检查是否在 PATH 中
        from shutil import which

        found = which(executable_name)
        if found:
            logger.info(f"Found 3proxy in PATH: {found}")
            return found

        # 未找到
        logger.error(
            f"3proxy executable not found. Please install 3proxy or place it in {proxy_dir}"
        )
        raise FileNotFoundError("3proxy executable not found")

    def generate_config(self) -> None:
        """
        生成 3proxy 配置文件
        """
        config_lines = [
            "# 3proxy configuration file",
            "# Auto-generated by Proxy Agent",
            "",
            f"log {self.log_file} D",
            'logformat "- +_L%t.%. %N.%p %E %U %C:%c %R:%r %O %I %h %T"',
            "",
            "# 认证配置",
        ]

        # 如果配置了用户名密码，则启用认证
        if self.proxy_username and self.proxy_password:
            config_lines.extend(
                [
                    f"users {self.proxy_username}:CL:{self.proxy_password}",
                    "auth strong",
                    "",
                ]
            )
        else:
            config_lines.extend(
                [
                    "auth none",
                    "",
                ]
            )

        # 允许所有 IP 访问（生产环境建议限制）
        config_lines.extend(
            [
                "allow *",
                "",
            ]
        )

        # 根据代理类型配置服务
        if self.proxy_type in ["http", "both"]:
            config_lines.extend(
                [
                    f"# HTTP Proxy on port {self.proxy_port}",
                    f"proxy -p{self.proxy_port}",
                    "",
                ]
            )

        if self.proxy_type in ["socks5", "both"]:
            # 如果是 both 模式，SOCKS5 使用下一个端口
            socks_port = (
                self.proxy_port if self.proxy_type == "socks5" else self.proxy_port + 1
            )
            config_lines.extend(
                [
                    f"# SOCKS5 Proxy on port {socks_port}",
                    f"socks -p{socks_port}",
                    "",
                ]
            )

        # 写入配置文件
        config_content = "\n".join(config_lines)
        with open(self.config_file, "w", encoding="utf-8") as f:
            f.write(config_content)

        logger.info(f"Generated 3proxy config: {self.config_file}")

    def start(self) -> bool:
        """
        启动 3proxy 服务

        Returns:
            bool: 是否启动成功
        """
        if self.is_running():
            logger.warning("3proxy is already running")
            return True

        try:
            # 生成配置文件
            self.generate_config()

            # 启动进程
            cmd = [self.executable, self.config_file]
            logger.info(f"Starting 3proxy: {' '.join(cmd)}")

            # 根据操作系统选择不同的启动方式
            if platform.system() == "Windows":
                # Windows 下隐藏控制台窗口
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                startupinfo.wShowWindow = subprocess.SW_HIDE
                self.process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    startupinfo=startupinfo,
                )
            else:
                # Linux 下直接启动
                self.process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    preexec_fn=os.setsid,  # 创建新的会话
                )

            # 等待一下，确保进程启动
            time.sleep(1)

            if self.is_running():
                logger.info(f"3proxy started successfully (PID: {self.process.pid})")
                return True
            else:
                logger.error("3proxy failed to start")
                return False

        except Exception as e:
            logger.error(f"Failed to start 3proxy: {e}")
            return False

    def stop(self) -> bool:
        """
        停止 3proxy 服务

        Returns:
            bool: 是否停止成功
        """
        if not self.is_running():
            logger.warning("3proxy is not running")
            return True

        try:
            logger.info(f"Stopping 3proxy (PID: {self.process.pid})")

            # 终止进程
            self.process.terminate()

            # 等待进程结束
            try:
                self.process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("3proxy did not terminate gracefully, killing it")
                self.process.kill()
                self.process.wait()

            self.process = None
            logger.info("3proxy stopped successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to stop 3proxy: {e}")
            return False

    def restart(self) -> bool:
        """
        重启 3proxy 服务

        Returns:
            bool: 是否重启成功
        """
        logger.info("Restarting 3proxy")
        self.stop()
        time.sleep(1)
        return self.start()

    def is_running(self) -> bool:
        """
        检查 3proxy 是否正在运行

        Returns:
            bool: 是否正在运行
        """
        if self.process is None:
            return False

        # 检查进程是否还存活
        return self.process.poll() is None

    def get_status(self) -> dict:
        """
        获取代理服务状态

        Returns:
            dict: 状态信息
        """
        is_running = self.is_running()

        status = {
            "running": is_running,
            "proxy_type": self.proxy_type,
            "proxy_port": self.proxy_port,
            "pid": self.process.pid if is_running else None,
        }

        if self.proxy_type == "both":
            status["socks5_port"] = self.proxy_port + 1

        return status
